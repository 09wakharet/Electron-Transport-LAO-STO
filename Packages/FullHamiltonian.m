(* ::Package:: *)

(* ::Input:: *)
(*BeginPackage["FullHamiltonian`"]*)
(**)
(*BaseMatrix::usage="MainFunction[x] returns the Hamiltonian, only missing the main diagonal energy, which is parametrized by kz."*)
(**)
(*Begin["Private`"]*)
(**)
(*BaseMatrix[MM_,NN_,\[Epsilon]1_,\[Epsilon]2_,H_,a_,\[Lambda]_,t1_,t2_ ]:=Module[*)
(*{m,m1,m2,m3,m4,m5,m6,m7,m8,m9,newm,totalCharge,chargeVector,potential,exteriorPoints,halfSpaceVoltage,halfSpaceList,voltageMatrix,tempTotal,tx,ty},*)
(*\[Alpha]=.529/a;(*Subscript[a, 0]/a, where Subscript[a, 0] is the Bohr radius*)*)
(*Ry=13.60569253;(*Rydberg unit of energy, in eV*)*)
(*mm=Floor[(MM+1)/2];(*along top of half space*)*)
(*nn=NN;*)
(**)
(*(*Poisson solver that implements the first part of the algorithm described below - it represents the Laplacian as a matrix operator then inverts it. Any solution to Poisson's equation is now found by multiplying the inverse matrix by the (forcing function \[Rho]? idk if you can call it that)*)*)
(*(*This is a symmetric finite difference method to solve the Poisson Equation*) *)
(*(*en.wikipedia.org/wiki/Discrete_Poisson_equation*)*)
(*(*construct D, the matrix operator that corresponds to the Laplacian. This is a 9 point stencil*)*)
(*periodicblock[b_,c_]:=c IdentityMatrix[MM-1]+DiagonalMatrix[Table[b,{i,0,MM-3}],1]+DiagonalMatrix[Table[b,{i,0,MM-3}],-1]+DiagonalMatrix[{b},-MM+2]+DiagonalMatrix[{b},MM-2];*)
(*m1 = periodicblock[-2./3,-1/6];*)
(*m2 = periodicblock[10/3,-2/3];*)
(*m3 =KroneckerProduct[DiagonalMatrix[Join[Table[1,{i,1,NN}],{0}],0],m2];*)
(**)
(*m4 =KroneckerProduct[DiagonalMatrix[Join[Table[1,{i,1,NN-1}],{0}],1],m1];*)
(*m5 =KroneckerProduct[DiagonalMatrix[Join[Table[1,{i,1,NN-1}],{0}],-1],m1];*)
(*m6 =KroneckerProduct[DiagonalMatrix[{1},NN],m1];*)
(*m7=1/2 IdentityMatrix[MM-1];*)
(*m8 =KroneckerProduct[DiagonalMatrix[{0,1},-NN+1],m7];*)
(*m9=KroneckerProduct[DiagonalMatrix[Join[Table[0,{i,1,NN}],{1}],0],-m7];*)
(*m = m3+m4+m5+m6+m8+m9;*)
(*newm=m3+m4+m5;*)
(**)
(*totalCharge= -(\[Epsilon]2/\[Epsilon]1)(\[Lambda]/N[\[Pi]])ArcTan[(MM a)/(2H)];*)
(*chargeDist[x_,y_]:=-Sin[(\[Pi] y)/MM]Exp[-((2\[Pi] x)/MM)];*)
(*tempTotal = Table[*)
(* N[chargeDist[i ,j ]],*)
(*{i,1,NN},*)
(*{j,1,MM-1}*)
(*]//Flatten//Total;*)
(*n[x_,y_]:=-((8N[\[Pi]]Ry \[Alpha])/\[Epsilon]2) N[chargeDist[x,y]]/tempTotal totalCharge;(*If[x\[Equal]Floor[1/2NN stepSize],0/(4 \[Pi] \[Epsilon]),0/(4 \[Pi] \[Epsilon])Cos[(x+y)]]*)(*Charge distribution*)*)
(*e1[j_]:=(8N[\[Pi]]Ry \[Alpha] \[Lambda] H a)/(2 N[\[Pi]]\[Epsilon]1 (H^2+(j-Floor[(MM+1)/2])^2 a^2));(*Normal component of electric field at top edge of the grid*)*)
(**)
(*(*Defines the list with the charge distribution Subscript[\[Rho], ij] generated from the user, augmented with the boundary conditions *)*)
(*chargeVector  = *)
(*Table[*)
(* n[i ,j ],*)
(*{i,1,NN},*)
(*{j,1,MM-1}*)
(*]//Flatten;*)
(**)
(*exteriorPoints = *)
(*Table[*)
(*  N[e1[j ]] ,*)
(*{j,1,MM-1}*)
(*]//Flatten;*)
(*chargeVector = Join[chargeVector, exteriorPoints];*)
(*chargeVector=chargeVector-1/2 newm.chargeVector;*)
(*(*Calculates the potential*)*)
(*potential = LinearSolve[m,chargeVector];*)
(**)
(*halfSpaceVoltage=Flatten[Table[*)
(*{i,Floor[(MM+1)/2]-j+1,potential[[j + (MM-1)(i-1)]]},*)
(*{i,1,NN},*)
(*{j,Floor[(MM+1)/2],1,-1}*)
(*],1];*)
(*halfSpaceList=Table[*)
(*halfSpaceVoltage[[All,3]][[j]],*)
(*{j,1,halfSpaceVoltage[[All,3]]//Length},*)
(*{i,1,3}*)
(*]//Flatten;*)
(**)
(*voltageMatrix=DiagonalMatrix[halfSpaceList];*)
(*tx = DiagonalMatrix[{t2,t1,t1},0];*)
(*ty = DiagonalMatrix[{t1,t2,t1},0];*)
(**)
(*(*These 4 matrices are interatomic bonding in each of the 4 directions in the x-y plane*)*)
(*m2 = KroneckerProduct[DiagonalMatrix[Table[1,{nn*mm-1}],1],ty];*)
(*m3 = KroneckerProduct[DiagonalMatrix[Table[1,{nn*mm-1}],-1],ty];*)
(*m4 = KroneckerProduct[DiagonalMatrix[Table[1,{nn*mm-mm}],mm],tx];*)
(*m5 = KroneckerProduct[DiagonalMatrix[Table[1,{nn*mm-mm}],-mm],tx];*)
(*m2+m3+m4+m5+voltageMatrix*)
(*]*)
(**)
(*End[]*)
(**)
(*EndPackage[]*)
